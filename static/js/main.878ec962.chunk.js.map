{"version":3,"sources":["Match/Match.jsx","MatchModifiers/MatchModifiers.jsx","MatchesOriginal/MatchesOriginal.jsx","TurnActionBar/TurnActionBar.jsx","MatchGame/MatchGame.jsx","TitlePage/TitlePage.jsx","TransitionRouteWrapper/TransitionRouteWrapper.jsx","App.js","serviceWorker.js","index.js"],"names":["Match","react_default","a","createElement","src","style","width","height","alt","MatchModifiers","props","incrementMatches","decrementMatches","currentMatch","minMatches","maxMatches","className","disabled","onClick","index_es","icon","faPlus","faMinus","MatchesOriginal","provisionalMatches","initialMatchesOnTurn","id","map","count","i","key","_","times","MatchModifiers_MatchModifiers","TurnActionBar","restartGame","resetTurn","finalizeTurn","hasChangeOccurred","e","preventDefault","MatchGame","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","prevMax","state","matchesWithInc","toConsumableArray","setState","matchesWithDec","_AITurn","curMatches","reduce","acc","remainingTurns","maxVal","max","indexOfMax","indexOf","newMatches","nimSum","console","log","_this$_getOptimalMove","_getOptimalMoveBasedOnSum","_this$_getOptimalMove2","slicedToArray","index","valueToRemove","optionalMatches","arguments","length","undefined","nextPlayer","_nextPlayer","currentPlayer","initialMatches","_initializeMatchesArray","userGoesFirst","PLAYER_USER","PLAYER_AI","matchVizOptions","name","visualizer","numberOfRows","matchCounts","prevProps","prevState","snapshot","winner","push","error","concat","forEach","curIndex","MatchesOriginal_MatchesOriginal","TurnActionBar_TurnActionBar","isEqual","Component","TitlePage","react_router_dom","to","TransitionRouteWrapper","WrappedComponent","children","App","routerRender","_ref","location","WrappedTitlePage","WrappedLearnPage","WrappedPlayPage","TransitionGroup","CSSTransition","timeout","react_router","exact","path","component","basename","process","render","Boolean","window","hostname","match","ReactDOM","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.878ec962.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nexport default function Match() {\r\n    const dimension = 75;\r\n    return (\r\n        <img\r\n            src=\"matchstick.png\"\r\n            style={{\r\n                'width': dimension,\r\n                'height': dimension,\r\n            }}\r\n            alt=\"One of the matches in this row\"\r\n        />\r\n    );\r\n}","import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\r\nimport { faPlus, faMinus } from '@fortawesome/free-solid-svg-icons';\r\nimport React from 'react';\r\nimport './MatchModifiers.css';\r\nexport default function MatchModifiers (props) {\r\n    const { incrementMatches, decrementMatches, currentMatch, minMatches, maxMatches } = props; \r\n    return (\r\n        <span className=\"match-modifier-btns\">\r\n            <button\r\n                className=\"btn btn-primary btn-sm\"\r\n                disabled={maxMatches}\r\n                onClick={() => incrementMatches(currentMatch)}\r\n            >\r\n                <FontAwesomeIcon icon={faPlus}/>\r\n            </button>\r\n            <button\r\n                className=\"btn btn-primary btn-sm\"\r\n                disabled={minMatches}\r\n                onClick={() => decrementMatches(currentMatch)}\r\n            >\r\n                <FontAwesomeIcon icon={faMinus}/>\r\n            </button>\r\n        </span>\r\n    );\r\n}","import React from 'react';\r\nimport Match from \"../Match/Match.jsx\";\r\nimport MatchModifiers from \"../MatchModifiers/MatchModifiers.jsx\";\r\nimport './MatchesOriginal.css'\r\nimport _ from 'lodash';\r\nexport default function MatchesOriginal (props) {\r\n    const { provisionalMatches, initialMatchesOnTurn, incrementMatches, decrementMatches } = props;\r\n    return (\r\n        <div id=\"match-original-game-container\">\r\n            {provisionalMatches.map((count, i) => {\r\n                return (\r\n                    <div className=\"match-row\" key={i}>\r\n                        <span className=\"matches-fixed-width-container\">\r\n                            {_.times(count, (i) => { \r\n                                return <Match key={i}/>\r\n                            })}\r\n                        </span>\r\n                        <MatchModifiers\r\n                            currentMatch={i}\r\n                            //TODO: Make this more generic\r\n                            maxMatches={count === initialMatchesOnTurn[i]}\r\n                            minMatches={count === 0}\r\n                            incrementMatches={incrementMatches}\r\n                            decrementMatches={decrementMatches}\r\n                        />\r\n                    </div>\r\n                );\r\n            })}\r\n        </div>\r\n    );\r\n}","import React from 'react';\r\nimport './TurnActionBar.css'\r\n\r\nexport default function TurnActionBar(props) {\r\n    const { restartGame, resetTurn, finalizeTurn, hasChangeOccurred } = props;\r\n\r\n    function handleRestartClick(e) { \r\n        e.preventDefault();\r\n        restartGame();\r\n    }\r\n    function handleDoneClick(e) { \r\n        e.preventDefault();\r\n        finalizeTurn();\r\n    }\r\n    function handleResetClick(e) { \r\n        e.preventDefault();\r\n        resetTurn();\r\n    }\r\n\r\n    return (\r\n        <div id=\"turn-action-bar\">\r\n            <button className=\"btn btn-outline-primary\" onClick={handleRestartClick}>Restart Game</button>\r\n            <button className=\"btn btn-outline-primary\" disabled={hasChangeOccurred} onClick={handleResetClick}>Reset Turn</button>\r\n            <button className=\"btn btn-outline-primary\" disabled={hasChangeOccurred} onClick={handleDoneClick}>Turn Finished</button>\r\n        </div> \r\n    );\r\n}","import React, { Component } from 'react';\r\nimport MatchesOriginal from '../MatchesOriginal/MatchesOriginal.jsx';\r\nimport TurnActionBar from '../TurnActionBar/TurnActionBar.jsx';\r\nimport _ from 'lodash';\r\nimport './MatchGame.css';\r\n// import MatchesLeftCollapsed from './MatchesLeftCollapsed.jsx'\r\n// import MatchesAsDecimal from './MatchesAsDecimal.jsx'\r\n// import MatchesAsBinary from './MatchesAsBinary.jsx'\r\n\r\nexport default class MatchGame extends Component {\r\n    constructor(props) { \r\n        super(props);\r\n        this.matchVizOptions = [\r\n            {\r\n                name: \"Original Matches\",\r\n                visualizer: MatchesOriginal\r\n            },\r\n            // {\r\n            //     name: \"Matches Left-Collapsed\",\r\n            //     visualizer: MatchesLeftCollapsed\r\n            // },\r\n            // {\r\n            //     name: \"Decimal Numbers\",\r\n            //     visualizer: MatchesAsDecimal\r\n            // },\r\n            // {\r\n            //     name: \"Binary Numbers\",\r\n            //     visualizer: MatchesAsBinary\r\n            // },\r\n        ]\r\n        this.PLAYER_USER = 0;\r\n        this.PLAYER_AI = 1;\r\n\r\n        // Configuration of Game State:\r\n        // TODO: Move into state once modifiable;\r\n        this.numberOfRows = 4;\r\n        this.userGoesFirst = true;\r\n\r\n        const matchCounts = this._initializeMatchesArray()\r\n        this.state = {\r\n            provisionalMatches: matchCounts,\r\n            initialMatchesOnTurn: matchCounts,\r\n            currentPlayer: this.PLAYER_USER\r\n        }\r\n    }\r\n\r\n    // Handle the automated turns of the AI anytime the screen updates\r\n    componentDidUpdate(prevProps, prevState, snapshot) {\r\n        if (_.max(this.state.initialMatchesOnTurn) === 0) {\r\n            // First - check to see if there is a winner:\r\n            const winner = this.state.currentPlayer === this.PLAYER_AI ? \"AI\" : \"User\";\r\n            // The winner is the first person to start their turn with a 0 maxMatches\r\n            console.log(\"Congratulations on winning \" + winner + \"!\");\r\n        } else if(this.state.currentPlayer === this.PLAYER_AI) { \r\n            // Else, if the AI's turn is up let the algo go!\r\n            this._AITurn()\r\n        }\r\n    }\r\n\r\n    // Return an initialized array of matches based on the number of rows the game has\r\n    _initializeMatchesArray() {\r\n        const matchCounts = [];\r\n        // For each row 0,1,2,3,... we have, push 1,3,5,7,... matches\r\n        for (let i = 0; i < this.numberOfRows; i++) { \r\n            matchCounts.push(1 + (2 * i)) \r\n        }\r\n        return matchCounts;\r\n    }\r\n\r\n    // Internally defined function for transitioning from one turn to the next\r\n    _nextPlayer() {\r\n        switch(this.state.currentPlayer) {\r\n            case this.PLAYER_AI:\r\n                return this.PLAYER_USER;\r\n            case this.PLAYER_USER:\r\n                return this.PLAYER_AI;\r\n            default: \r\n                console.error(`Switching current player but the turn-switch mechanic is undefined for this player ${this.state.currentPlayer}`);\r\n                return null;\r\n        }\r\n    }\r\n\r\n    // Increments the current count for the matches in the 'ith' row, being careful to not go above the previous highest value for that row\r\n    incrementMatches = (i) => {\r\n        const prevMax = this.state.initialMatchesOnTurn[i];\r\n        const curCount = this.state.provisionalMatches[i];\r\n        if (curCount + 1 > prevMax) {\r\n            return\r\n        } else {\r\n            const matchesWithInc = [...this.state.provisionalMatches];\r\n            matchesWithInc[i] += 1;\r\n            this.setState({\r\n                provisionalMatches: matchesWithInc\r\n            });\r\n        }\r\n    }\r\n\r\n    // Decremenets the current count for the matches in the 'ith' row, being careful to not go below 0;\r\n    decrementMatches = (i) => {\r\n        const curCount = this.state.provisionalMatches[i];\r\n        if (curCount - 1 < 0) {\r\n            return\r\n        } else {\r\n            const matchesWithDec = [...this.state.provisionalMatches];\r\n            matchesWithDec[i] -= 1;\r\n            this.setState({\r\n                provisionalMatches: matchesWithDec\r\n            });\r\n        }\r\n    }\r\n\r\n    // Resets the matches to how they were oriented at the beginning of the turn\r\n    resetTurn = () => {\r\n        this.setState({\r\n            provisionalMatches: this.state.initialMatchesOnTurn\r\n        });\r\n    }\r\n\r\n    // TODO: Better name;\r\n    // Finding a move baed on the nimSum: find a row with matchCount 'x' for which x > 0 && x ^ nimSum < x;\r\n    // Return the index of the current row, and the original count minus the XOR value \r\n    _getOptimalMoveBasedOnSum(nimSum) {\r\n        // Have an illegal index initially; inital value to remove shouldn't matter\r\n        let index = -1;\r\n        let valueToRemove = 0;\r\n        // Iterate over all our currentMatches\r\n        this.state.provisionalMatches.forEach((count, curIndex) => {\r\n            ///////////////////////\r\n            // Our Algorithm //////\r\n            //// Short, But Verbose\r\n            ///////////////////////\r\n            // To determine the ideal valueToRemove, let's think about what we want to end up with and work backwards.\r\n            //\r\n            // The optimal (non-endgame) strategy is to remove matches from some target row such that:\r\n            //  - The nim-sum of all _remaining_ matches is 0;\r\n            //  - i.e. x_0 ^ x_1 ^ x_target's remaining matches ^ ... ^ x_n = 0\r\n            // \r\n            // Remark 0: 0 ^ x = x for any number x\r\n            // Remark 1: x ^ x = 0 for any number x\r\n            // \r\n            // One way of achieving our ideal move this is to ensure that: \r\n            //  - After modifying our target row, the number of remaining matches should be:\r\n            //    (x_0 ^ x_1 ^ ... ^ x_n) many matches, since this value will XOR with our remaining matches \r\n            //    for a nimSum of 0;\r\n            // Said another way:\r\n            //  - Can we remove some 'n' matches from our target row such that\r\n            //     x_target - n === (x_0 ^ x_1 ^ ... ^ x_n), for all x !== x_target\r\n            //\r\n            // Important question yet to be answered: Which row is our target row?!\r\n            // \r\n            // To find x_target, we should iterate over all our rows and check the condition we described above.\r\n            // Something like, for every row 'i' with matches 'x_i':\r\n            // - Is there some number of matches 'n' s.t. \r\n            //   x_i - n === (x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i\r\n            // \r\n            // We're looking for the valueToRemove, 'n', so if we move our terms around a bit, we might be done!\r\n            // - n = 'x_i - (x_0 ^ x_1 ^ ... ^ x_n)' for all x !== x_i\r\n            // \r\n            // Except, minor problem -- 'n' might be negative based on the formula above!\r\n            // Consider matches [1,5,2]\r\n            // Row one has x_0 = 1\r\n            // nimSum of all rows except the first = 7\r\n            // 1 - 7 = (-6)\r\n            //\r\n            // We can't remove a negative number of matches, or add more matches than the number we started with \r\n            // One way we can take this into account is by only considering scenarios in which:\r\n            // - (x_i - n) < x_i\r\n            // Said another way: \r\n            // - '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i' < x_i\r\n            // By requiring this condition be met, we can ensure that our n is always > 0\r\n            //\r\n            // Great! So we have our necessary conditions to check for\r\n            // We know how to derive n from '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i'\r\n            // We just need to calculate: '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i'\r\n            //\r\n            // Remark 2: We know that our nimSum = (x_0 ^ x_1 ^ ... ^ x_n)\r\n            // \r\n            // Combining remarks 0, 1 and 2, we can calculate '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i' by computing:\r\n            // - x_i ^ nimSum\r\n            // Proof of equality fully expanded: \r\n            // - x_i ^ x_0 ^ x_1 ^ ... ^ x_i ^ ... ^ x_n) | Expand nimSum\r\n            // - x_i ^ x_i ^ x_0 ^ ... ^ x_n              | Chained Communitivity of ^ let's us move our x_i together\r\n            // - 0 ^ x_0 ^ ... ^ x_n                      | From Remark 1, x_i ^ x_i === 0\r\n            // - x_0 ^ ... ^ x_n for x !== x_i            | From Remark 0, x ^ 0 === x\r\n            //\r\n            // One last detail: once we find an optimal number of elements to remove, we can skip all the other rows\r\n            // \r\n            // Putting it all together now, our algorithm is:\r\n            // - For every row 'i' with matches 'x_i':\r\n            //      - Compute 'x_0 ^ ... ^ x_n for x !== x_i' by performing x_i ^ nimSum\r\n            //      - Check that x_0 ^ ... ^ x_n for x !== x_i is less that x_i\r\n            //      - If it is, 'n' is equal to 'x_i - (x_0 ^ ... ^ x_n for x !== x_i)',\r\n            //      - Make note that we've got an optimal move to make, so we can skip through all other rows\r\n            //  - Return the row of interest's index 'i' and the value 'n' to remove \r\n\r\n            if (index !== -1) return;\r\n            // If the result of count XOR nimSum is < count, this is the row we can remove a value from! \r\n            if ((count ^ nimSum) < count) {\r\n                // Track the index,\r\n                index = curIndex;\r\n                // And note our value to remove \r\n                valueToRemove = count - (count ^ nimSum);\r\n            }\r\n        });\r\n        return [index, valueToRemove]; \r\n    }\r\n\r\n    _AITurn= () =>{\r\n        // Strategy can be broken up into two modes: Endgame and typical\r\n        // First, check to see if we are in an endgame orientation - specifically, if there is <= 1 row left with more than one match\r\n        const curMatches = this.state.provisionalMatches;\r\n        const isEndGame = _.reduce(curMatches, (acc, count) => count > 1 ? acc + 1 : acc, 0) <= 1;\r\n        if (isEndGame) {\r\n            // Calc the # of remaining turns by looking at the non-zero rows\r\n            const remainingTurns = _.reduce(curMatches, (acc, count) => count > 0 ? acc + 1 : acc, 0);\r\n            // Get the max value \r\n            const maxVal = _.max(curMatches);\r\n            const indexOfMax = curMatches.indexOf(maxVal)\r\n            const newMatches = [...curMatches];\r\n            // Subtract the maxVal - unless the number\r\n            newMatches[indexOfMax] -= (maxVal - (remainingTurns % 2));\r\n            this.finalizeTurn(newMatches);\r\n        } else { \r\n            // First, get the nim sum of all the remaining match-rows, i.e. XOR all counts together\r\n            const nimSum = _.reduce(curMatches, (nimSum, count) => count ^ nimSum, 0);\r\n            console.log('nimSum: ', nimSum);\r\n            // Then, get the next value to remove and the index from the nimSum - if there is such a move\r\n            const [index, valueToRemove] = this._getOptimalMoveBasedOnSum(nimSum);\r\n            if (index === -1) {\r\n                console.log(\"Index is -1 - no traditional removals available\");\r\n            } else {\r\n                const newMatches = [...curMatches];\r\n                newMatches[index] -= valueToRemove;\r\n                console.log('newMatches: ', newMatches);\r\n                this.finalizeTurn(newMatches)\r\n            }\r\n        }\r\n    }\r\n\r\n    // Finalize a turn by updating matches (using optional arg or current provisional) and switching to the next player\r\n    finalizeTurn = (optionalMatches=null) => {\r\n        // New matches are either provided matches or the provisional matches\r\n        const newMatches = optionalMatches ? optionalMatches : this.state.provisionalMatches\r\n        const nextPlayer = this._nextPlayer();\r\n        this.setState({\r\n            initialMatchesOnTurn: newMatches,\r\n            provisionalMatches: newMatches,\r\n            currentPlayer: nextPlayer\r\n        });\r\n    }\r\n\r\n    // Restarts the game to it's initial configuration\r\n    restartGame = () => {\r\n        // Get the inital matches array\r\n        const initialMatches = this._initializeMatchesArray();\r\n        this.setState({\r\n            provisionalMatches: initialMatches,\r\n            initialMatchesOnTurn: initialMatches,\r\n            // Starting player is based on whether or not the userGoesFirst\r\n            currentPlayer: this.userGoesFirst ? this.PLAYER_USER : this.PLAYER_AI\r\n        });\r\n    }\r\n\r\n    render() { \r\n        return (\r\n            <div id=\"match-game-container\">\r\n                <MatchesOriginal\r\n                    provisionalMatches={this.state.provisionalMatches}\r\n                    initialMatchesOnTurn={this.state.initialMatchesOnTurn}\r\n                    incrementMatches={this.incrementMatches}\r\n                    decrementMatches={this.decrementMatches}\r\n                />\r\n                <TurnActionBar\r\n                    restartGame={this.restartGame}\r\n                    resetTurn={this.resetTurn}\r\n                    finalizeTurn={this.finalizeTurn}\r\n                    hasChangeOccurred={_.isEqual(this.state.provisionalMatches, this.state.initialMatchesOnTurn)}\r\n                />\r\n            </div>\r\n        );\r\n    }\r\n}","import React from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport './TitlePage.css';\r\n\r\nexport default function TitlePage() { \r\n    return (\r\n        <section id=\"title-page\">\r\n            <h1>NIM</h1>\r\n            <div id=\"title-buttons\">\r\n                <Link to=\"/learn\">\r\n                    <button className=\"btn btn-lg btn-primary\">\r\n                        Learn\r\n                    </button>\r\n                </Link>\r\n                <Link to=\"/play\">\r\n                    <button className=\"btn btn-lg btn-primary\">\r\n                        Play\r\n                    </button>\r\n                </Link>\r\n            </div>\r\n        </section>\r\n    );\r\n}","import React from 'react';\r\nimport './TransitionRouteWrapper.css';\r\n\r\nexport default function TransitionRouteWrapper(WrappedComponent) {\r\n    function ExtendedComponent(props) { \r\n        return (\r\n            <div className=\"route\">\r\n                <WrappedComponent>\r\n                    {props.children}\r\n                </WrappedComponent>\r\n            </div>\r\n        );\r\n    }\r\n    return ExtendedComponent;\r\n}","import React, { Component } from 'react';\r\nimport MatchGame from './MatchGame/MatchGame.jsx'; \r\nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\r\nimport { TransitionGroup, CSSTransition } from \"react-transition-group\";\r\nimport './App.css';\r\nimport TitlePage from './TitlePage/TitlePage.jsx';\r\nimport TransitionRouteWrapper from './TransitionRouteWrapper/TransitionRouteWrapper.jsx';\r\n\r\nclass App extends Component {\r\n    routerRender = ({location}) => { \r\n        const WrappedTitlePage = TransitionRouteWrapper(TitlePage)\r\n        const WrappedLearnPage = TransitionRouteWrapper(MatchGame)\r\n        const WrappedPlayPage = TransitionRouteWrapper(MatchGame)\r\n        return (\r\n            <TransitionGroup>\r\n                <CSSTransition\r\n                    key={location.key}\r\n                    timeout={1000}\r\n                >\r\n                    <Switch location={location}>\r\n                        <Route exact path=\"/\" component={WrappedTitlePage}/>\r\n                        <Route path=\"/learn\" component={WrappedLearnPage}/>\r\n                        <Route path=\"/play\" component={WrappedPlayPage}/>\r\n                    </Switch>\r\n                </CSSTransition>\r\n            </TransitionGroup>\r\n        );\r\n    }\r\n    render() {\r\n        return (\r\n            <Router basename={process.env.PUBLIC_URL}>\r\n                <Route render={this.routerRender}/>\r\n            </Router>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\nimport 'bootstrap/dist/css/bootstrap.css';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}