{"version":3,"sources":["Match/Match.jsx","MatchModifiers/MatchModifiers.jsx","MatchesOriginal/MatchesOriginal.jsx","ForceAIMoveButton/ForceAIMoveButton.js","TurnActionBar/TurnActionBar.jsx","MatchGame/MatchGame.jsx","LinkButton/LinkButton.js","WinPage/WinPage.js","LosePage/LosePage.js","ErrorPage/ErrorPage.js","GameOverPage/GameOverPage.js","TitlePage/TitlePage.jsx","TransitionRouteWrapper/TransitionRouteWrapper.jsx","NimTopBar/NimTopBar.js","App.js","serviceWorker.js","index.js"],"names":["Match","react_default","a","createElement","src","className","alt","MatchModifiers","props","incrementMatches","decrementMatches","currentMatch","minMatches","maxMatches","isRowLocked","disabled","onClick","index_es","icon","faPlus","faMinus","MatchesOriginal","provisionalMatches","initialMatchesOnTurn","hasChangeOccurred","id","map","count","i","key","_","times","Match_Match","MatchModifiers_MatchModifiers","ForceAIMoveButton","type","handleForceAIMoveButton","isFirstTurn","TurnActionBar","restartGame","resetTurn","finalizeTurn","e","preventDefault","MatchGame","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","prevMax","state","matchesWithInc","toConsumableArray","setState","matchesWithDec","_AITurn","curMatches","isEndGame","reduce","acc","console","log","remainingTurns","maxVal","max","indexOfMax","indexOf","newMatches","matchesToRemove","nimSum","_this$_getOptimalMove","_getOptimalMoveBasedOnSum","_this$_getOptimalMove2","slicedToArray","index","valueToRemove","validRowsIndexes","numberOfMatches","push","randomRowMatchCount","Math","floor","random","length","optionalMatches","arguments","undefined","nextPlayer","_nextPlayer","currentPlayer","initialMatches","_initializeMatchesArray","userGoesFirst","PLAYER_USER","PLAYER_AI","matchVizOptions","name","visualizer","numberOfRows","matchCounts","winner","prevProps","prevState","snapshot","error","concat","forEach","curIndex","isEqual","react_router","to","pathname","search","MatchesOriginal_MatchesOriginal","TurnActionBar_TurnActionBar","Component","PlayButton","displayText","react_router_dom","WinPage","Fragment","LosePage","ErrorPage","GameOverPage","GameOverScreen","values","queryString","parse","location","TitlePage","TransitionRouteWrapper","WrappedComponent","children","NimTopBar","href","App","routerRender","_ref","WrappedTitlePage","WrappedGameOverPage","WrappedLearnPage","WrappedPlayPage","WrappedErrorPage","TransitionGroup","CSSTransition","timeout","exact","path","component","basename","process","NimTopBar_NimTopBar","render","Boolean","window","hostname","match","ReactDOM","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.1081a290.chunk.js","sourcesContent":["import React from 'react';\nimport './Match.css'\n\nexport default function Match() {\n    return (\n        <img\n            src=\"matchstick-2.png\"\n            className=\"match\"\n            alt=\"One of the matches in this row\"\n        />\n    );\n}","import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport { faPlus, faMinus } from '@fortawesome/free-solid-svg-icons';\nimport React from 'react';\nimport './MatchModifiers.css';\nexport default function MatchModifiers (props) {\n    const { incrementMatches, decrementMatches, currentMatch, minMatches, maxMatches, isRowLocked} = props; \n    return (\n        <span className=\"match-modifier-btns\">\n            <button\n                className=\"btn btn-primary btn-sm\"\n                disabled={maxMatches || isRowLocked}\n                onClick={() => incrementMatches(currentMatch)}\n            >\n                <FontAwesomeIcon icon={faPlus}/>\n            </button>\n            <button\n                className=\"btn btn-primary btn-sm\"\n                disabled={minMatches || isRowLocked}\n                onClick={() => decrementMatches(currentMatch)}\n            >\n                <FontAwesomeIcon icon={faMinus}/>\n            </button>\n        </span>\n    );\n}","import React from 'react';\nimport Match from \"../Match/Match.jsx\";\nimport MatchModifiers from \"../MatchModifiers/MatchModifiers.jsx\";\nimport './MatchesOriginal.css'\nimport _ from 'lodash';\nexport default function MatchesOriginal (props) {\n    const { provisionalMatches, initialMatchesOnTurn, incrementMatches, decrementMatches, hasChangeOccurred } = props;\n    return (\n        <div id=\"match-original-game-container\">\n            {provisionalMatches.map((count, i) => {\n                // For every row of matches, if a change has occured, we want to lock any rows that aren't in the process of being changed \n                // This ensures that only one row can be modified at a given time\n                const isRowLocked = hasChangeOccurred && (count === initialMatchesOnTurn[i]);\n                return (\n                    <div className=\"match-row\" key={i}>\n                        <span className=\"matches-fixed-width-container\">\n                            {_.times(count, (i) => { \n                                return <Match key={i}/>\n                            })}\n                        </span>\n                        <MatchModifiers\n                            currentMatch={i}\n                            //TODO: Make this more generic\n                            maxMatches={count === initialMatchesOnTurn[i]}\n                            minMatches={count === 0}\n                            incrementMatches={incrementMatches}\n                            decrementMatches={decrementMatches}\n                            isRowLocked={isRowLocked}\n                        />\n                    </div>\n                );\n            })}\n        </div>\n    );\n}","import React from 'react';\n\nexport default function ForceAIMoveButton(props) {\n    return (\n        <button type=\"button\" className=\"btn btn-outline-primary\" onClick={props.handleForceAIMoveButton} disabled={!props.isFirstTurn}>AI Moves First</button>\n    );\n}","import React from 'react';\nimport './TurnActionBar.css'\nimport ForceAIMoveButton from '../ForceAIMoveButton/ForceAIMoveButton';\n\nexport default function TurnActionBar(props) {\n    const { restartGame, resetTurn, finalizeTurn, hasChangeOccurred, isFirstTurn, handleForceAIMoveButton } = props;\n\n    function handleRestartClick(e) { \n        e.preventDefault();\n        restartGame();\n    }\n    function handleDoneClick(e) { \n        e.preventDefault();\n        finalizeTurn();\n    }\n    function handleResetClick(e) { \n        e.preventDefault();\n        resetTurn();\n    }\n    function handleAIMoveClick(e) { \n        e.preventDefault();\n        handleForceAIMoveButton();\n    }\n\n    return (\n        <div id=\"turn-action-bar\">\n            <button className=\"btn btn-outline-primary\" onClick={handleRestartClick}>Restart Game</button>\n            <button className=\"btn btn-outline-primary\" disabled={!hasChangeOccurred} onClick={handleResetClick}>Reset Turn</button>\n            <button className=\"btn btn-outline-primary\" disabled={!hasChangeOccurred} onClick={handleDoneClick}>Turn Finished</button>\n            <ForceAIMoveButton\n                isFirstTurn={isFirstTurn}\n                handleForceAIMoveButton={handleAIMoveClick}\n            />\n        </div> \n    );\n}","import React, { Component } from 'react';\nimport { Redirect } from 'react-router'\nimport MatchesOriginal from '../MatchesOriginal/MatchesOriginal.jsx';\nimport TurnActionBar from '../TurnActionBar/TurnActionBar.jsx';\nimport ForceAIMoveButton from '../ForceAIMoveButton/ForceAIMoveButton.js';\nimport _ from 'lodash';\n// import MatchesLeftCollapsed from './MatchesLeftCollapsed.jsx'\n// import MatchesAsDecimal from './MatchesAsDecimal.jsx'\n// import MatchesAsBinary from './MatchesAsBinary.jsx'\n\nexport default class MatchGame extends Component {\n    constructor(props) { \n        super(props);\n        this.matchVizOptions = [\n            {\n                name: \"Original Matches\",\n                visualizer: MatchesOriginal\n            },\n            // {\n            //     name: \"Matches Left-Collapsed\",\n            //     visualizer: MatchesLeftCollapsed\n            // },\n            // {\n            //     name: \"Decimal Numbers\",\n            //     visualizer: MatchesAsDecimal\n            // },\n            // {\n            //     name: \"Binary Numbers\",\n            //     visualizer: MatchesAsBinary\n            // },\n        ]\n        this.PLAYER_USER = 0;\n        this.PLAYER_AI = 1;\n\n        // Configuration of Game State:\n        // TODO: Move into state once modifiable;\n        this.numberOfRows = 4;\n        this.userGoesFirst = true;\n\n        const matchCounts = this._initializeMatchesArray()\n        this.state = {\n            provisionalMatches: matchCounts,\n            initialMatchesOnTurn: matchCounts,\n            currentPlayer: this.PLAYER_USER,\n            isFirstTurn: true,\n            winner: undefined\n        }\n    }\n\n    // Handle the automated turns of the AI anytime the screen updates\n    componentDidUpdate(prevProps, prevState, snapshot) {\n        if (_.max(this.state.initialMatchesOnTurn) === 0 && !this.state.winner) {\n            // First - check to see if there is a winner:\n            const winner = this.state.currentPlayer === this.PLAYER_AI ? \"AI\" : \"User\";\n            // The winner is the first person to start their turn with a 0 maxMatches\n            console.log(\"Congratulations on winning \" + winner + \"!\");\n            this.setState({\n                winner\n            });\n        } else if(this.state.currentPlayer === this.PLAYER_AI) { \n            // Else, if the AI's turn is up let the algo go!\n            this._AITurn()\n        }\n    }\n\n    // Return an initialized array of matches based on the number of rows the game has\n    _initializeMatchesArray() {\n        const matchCounts = [];\n        // For each row 0,1,2,3,... we have, push 1,3,5,7,... matches\n        for (let i = 0; i < this.numberOfRows; i++) { \n            matchCounts.push(1 + (2 * i)) \n        }\n        return matchCounts;\n    }\n\n    // Internally defined function for transitioning from one turn to the next\n    _nextPlayer() {\n        switch(this.state.currentPlayer) {\n            case this.PLAYER_AI:\n                return this.PLAYER_USER;\n            case this.PLAYER_USER:\n                return this.PLAYER_AI;\n            default: \n                console.error(`Switching current player but the turn-switch mechanic is undefined for this player ${this.state.currentPlayer}`);\n                return null;\n        }\n    }\n\n    // Increments the current count for the matches in the 'ith' row, being careful to not go above the previous highest value for that row\n    incrementMatches = (i) => {\n        const prevMax = this.state.initialMatchesOnTurn[i];\n        const curCount = this.state.provisionalMatches[i];\n        if (curCount + 1 > prevMax) {\n            return\n        } else {\n            const matchesWithInc = [...this.state.provisionalMatches];\n            matchesWithInc[i] += 1;\n            this.setState({\n                provisionalMatches: matchesWithInc\n            });\n        }\n    }\n\n    // Decremenets the current count for the matches in the 'ith' row, being careful to not go below 0;\n    decrementMatches = (i) => {\n        const curCount = this.state.provisionalMatches[i];\n        if (curCount - 1 < 0) {\n            return\n        } else {\n            const matchesWithDec = [...this.state.provisionalMatches];\n            matchesWithDec[i] -= 1;\n            this.setState({\n                provisionalMatches: matchesWithDec\n            });\n        }\n    }\n\n    // Resets the matches to how they were oriented at the beginning of the turn\n    resetTurn = () => {\n        this.setState({\n            provisionalMatches: this.state.initialMatchesOnTurn\n        });\n    }\n\n    // TODO: Better name;\n    // Finding a move baed on the nimSum: find a row with matchCount 'x' for which x > 0 && x ^ nimSum < x;\n    // Return the index of the current row, and the original count minus the XOR value \n    _getOptimalMoveBasedOnSum(nimSum) {\n        // Have an illegal index initially; inital value to remove shouldn't matter\n        let index = -1;\n        let valueToRemove = 0;\n        // Iterate over all our currentMatches\n        this.state.provisionalMatches.forEach((count, curIndex) => {\n            ///////////////////////\n            // Our Algorithm //////\n            //// Short, But Verbose\n            ///////////////////////\n            // To determine the ideal valueToRemove, let's think about what we want to end up with and work backwards.\n            //\n            // The optimal (non-endgame) strategy is to remove matches from some target row such that:\n            //  - The nim-sum of all _remaining_ matches is 0;\n            //  - i.e. x_0 ^ x_1 ^ x_target's remaining matches ^ ... ^ x_n = 0\n            // \n            // Remark 0: 0 ^ x = x for any number x\n            // Remark 1: x ^ x = 0 for any number x\n            // \n            // One way of achieving our ideal move this is to ensure that: \n            //  - After modifying our target row, the number of remaining matches should be:\n            //    (x_0 ^ x_1 ^ ... ^ x_n) many matches, since this value will XOR with our remaining matches \n            //    for a nimSum of 0;\n            // Said another way:\n            //  - Can we remove some 'n' matches from our target row such that\n            //     x_target - n === (x_0 ^ x_1 ^ ... ^ x_n), for all x !== x_target\n            //\n            // Important question yet to be answered: Which row is our target row?!\n            // \n            // To find x_target, we should iterate over all our rows and check the condition we described above.\n            // Something like, for every row 'i' with matches 'x_i':\n            // - Is there some number of matches 'n' s.t. \n            //   x_i - n === (x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i\n            // \n            // We're looking for the valueToRemove, 'n', so if we move our terms around a bit, we might be done!\n            // - n = 'x_i - (x_0 ^ x_1 ^ ... ^ x_n)' for all x !== x_i\n            // \n            // Except, minor problem -- 'n' might be negative based on the formula above!\n            // Consider matches [1,5,2]\n            // Row one has x_0 = 1\n            // nimSum of all rows except the first = 7\n            // 1 - 7 = (-6)\n            //\n            // We can't remove a negative number of matches, or add more matches than the number we started with \n            // One way we can take this into account is by only considering scenarios in which:\n            // - (x_i - n) < x_i\n            // Said another way: \n            // - '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i' < x_i\n            // By requiring this condition be met, we can ensure that our n is always > 0\n            //\n            // Great! So we have our necessary conditions to check for\n            // We know how to derive n from '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i'\n            // We just need to calculate: '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i'\n            //\n            // Remark 2: We know that our nimSum = (x_0 ^ x_1 ^ ... ^ x_n)\n            // \n            // Combining remarks 0, 1 and 2, we can calculate '(x_0 ^ x_1 ^ ... ^ x_n) for all x !== x_i' by computing:\n            // - x_i ^ nimSum\n            // Proof of equality fully expanded: \n            // - x_i ^ x_0 ^ x_1 ^ ... ^ x_i ^ ... ^ x_n) | Expand nimSum\n            // - x_i ^ x_i ^ x_0 ^ ... ^ x_n              | Chained Communitivity of ^ let's us move our x_i together\n            // - 0 ^ x_0 ^ ... ^ x_n                      | From Remark 1, x_i ^ x_i === 0\n            // - x_0 ^ ... ^ x_n for x !== x_i            | From Remark 0, x ^ 0 === x\n            //\n            // One last detail: once we find an optimal number of elements to remove, we can skip all the other rows\n            // \n            // Putting it all together now, our algorithm is:\n            // - For every row 'i' with matches 'x_i':\n            //      - Compute 'x_0 ^ ... ^ x_n for x !== x_i' by performing x_i ^ nimSum\n            //      - Check that x_0 ^ ... ^ x_n for x !== x_i is less that x_i\n            //      - If it is, 'n' is equal to 'x_i - (x_0 ^ ... ^ x_n for x !== x_i)',\n            //      - Make note that we've got an optimal move to make, so we can skip through all other rows\n            //  - Return the row of interest's index 'i' and the value 'n' to remove \n\n            if (index !== -1) return;\n            // If the result of count XOR nimSum is < count, this is the row we can remove a value from! \n            if ((count ^ nimSum) < count) {\n                // Track the index,\n                index = curIndex;\n                // And note our value to remove \n                valueToRemove = count - (count ^ nimSum);\n            }\n        });\n        return [index, valueToRemove]; \n    }\n\n    _AITurn= () =>{\n        // Strategy can be broken up into two modes: Endgame and typical\n        // First, check to see if we are in an endgame orientation - specifically, if there is <= 1 row left with more than one match\n        const curMatches = this.state.initialMatchesOnTurn;\n        const isEndGame = _.reduce(curMatches, (acc, count) => count > 1 ? acc + 1 : acc, 0) <= 1;\n        console.log('isEndGame: ', isEndGame);\n        if (isEndGame) {\n            // Calc the # of remaining turns by looking at the non-zero rows\n            const remainingTurns = _.reduce(curMatches, (acc, count) => count > 0 ? acc + 1 : acc, 0);\n            console.log('remainingTurns: ', remainingTurns);\n            // Get the max value \n            const maxVal = _.max(curMatches);\n            const indexOfMax = curMatches.indexOf(maxVal)\n            \n            const newMatches = [...curMatches];\n            // Get the number of matches to remove\n            const matchesToRemove = (maxVal - (remainingTurns % 2));\n            // If the matchesToREmove is zero, the AI cannot win; just remove the maxVal\n            if (matchesToRemove === 0) { \n                newMatches[indexOfMax] -= maxVal;\n            } else { \n                newMatches[indexOfMax] -= matchesToRemove;\n            }\n            this.finalizeTurn(newMatches);\n        } else { \n            // First, get the nim sum of all the remaining match-rows, i.e. XOR all counts together\n            const nimSum = _.reduce(curMatches, (nimSum, count) => count ^ nimSum, 0);\n            // console.log('nimSum: ', nimSum);\n            // Then, get the next value to remove and the index from the nimSum - if there is such a move\n            let [index, valueToRemove] = this._getOptimalMoveBasedOnSum(nimSum);\n            if (index === -1) {\n                // If there's on optimal move, pick a random row, pick a random number of matches;\n                const validRowsIndexes = _.reduce(curMatches, (acc, numberOfMatches, i) => {\n                    if (numberOfMatches === 0) {\n                        return acc;\n                    } else {\n                        acc.push(i);\n                        return acc;\n                    }\n                }, []);\n                // Pick a randomRow by index\n                index = validRowsIndexes[Math.floor(Math.random()*(validRowsIndexes.length))];\n                // Get the matches in that row by looking at the curMatches array\n                const randomRowMatchCount = curMatches[index];\n                // To get a random amount of matches to remove, use random to seed a valu between 0..1\n                // Multiply that my the matchCount to map it between 0...matchCount - 1; \n                // Add one to make sure we remove between 1...matchCount many matches.\n                valueToRemove = Math.floor(Math.random()*randomRowMatchCount) + 1\n            }\n            const newMatches = [...curMatches];\n            newMatches[index] -= valueToRemove;\n            this.finalizeTurn(newMatches)\n        }\n    }\n\n    // Finalize a turn by updating matches (using optional arg or current provisional) and switching to the next player\n    finalizeTurn = (optionalMatches=null) => {\n        // New matches are either provided matches or the provisional matches\n        const newMatches = optionalMatches ? optionalMatches : this.state.provisionalMatches\n        const nextPlayer = this._nextPlayer();\n        this.setState({\n            initialMatchesOnTurn: newMatches,\n            provisionalMatches: newMatches,\n            isFirstTurn: false,\n            currentPlayer: nextPlayer\n        });\n    }\n\n    // Restarts the game to it's initial configuration\n    restartGame = () => {\n        // Get the inital matches array\n        const initialMatches = this._initializeMatchesArray();\n        this.setState({\n            provisionalMatches: initialMatches,\n            initialMatchesOnTurn: initialMatches,\n            isFirstTurn: true,\n            // Starting player is based on whether or not the userGoesFirst\n            currentPlayer: this.userGoesFirst ? this.PLAYER_USER : this.PLAYER_AI\n        });\n    }\n\n    handleForceAIMoveButton = () => { \n        this.setState({\n            currentPlayer: this.PLAYER_AI\n        });\n    }\n\n    render() {\n        const hasChangeOccurred = !_.isEqual(this.state.provisionalMatches, this.state.initialMatchesOnTurn);\n\n        // If there's a winner, redirect to the winner page\n        if (this.state.winner) { \n            return <Redirect push to={{\n                pathname: \"/gameover\",\n                search: \"?winner=\" + this.state.winner\n            }}/>\n        }\n        // Else, just render the current game\n        return (\n            <div id=\"match-game-container\">\n                {/* TODO: Make this use the application state to determine the current version of the game that's loaded */}\n                <MatchesOriginal\n                    provisionalMatches={this.state.provisionalMatches}\n                    initialMatchesOnTurn={this.state.initialMatchesOnTurn}\n                    incrementMatches={this.incrementMatches}\n                    decrementMatches={this.decrementMatches}\n                    hasChangeOccurred={hasChangeOccurred}\n                    />\n                <TurnActionBar\n                    isFirstTurn={this.state.isFirstTurn}\n                    restartGame={this.restartGame}\n                    resetTurn={this.resetTurn}\n                    finalizeTurn={this.finalizeTurn}\n                    handleForceAIMoveButton={this.handleForceAIMoveButton}\n                    hasChangeOccurred={hasChangeOccurred}\n                />\n            </div>\n        );\n    }\n}","import React from 'react'; \nimport { Link } from 'react-router-dom';\n\nexport default function PlayButton(props) {\n    const { pathname, displayText } = props;\n    return (\n        <Link to={pathname}>\n            <button className=\"btn btn-lg btn-outline-primary\">\n                {displayText}\n            </button>\n        </Link>\n    )\n}","import React from 'react';\nimport LinkButton from '../LinkButton/LinkButton.js';\n\nexport default function WinPage(props) {\n    return (\n        <React.Fragment>\n            <div className=\"jumbotron text-center\">\n                <h1 className=\"display-3 \">Congratulations</h1>\n                <h1 className=\"display-4 mb-5\">You beat the AI!</h1>\n            </div>\n            <div className=\"d-flex justify-content-around m-5\" id=\"nav-btns\">\n                <LinkButton pathname=\"/play\" displayText=\"Play Again\"/>\n                <LinkButton pathname=\"/\" displayText=\"Back Home\"/>\n            </div>\n        </React.Fragment>\n    );\n}","import React from 'react';\nimport LinkButton from '../LinkButton/LinkButton.js';\n\nexport default function LosePage(props) {\n    return (\n        <React.Fragment>\n            <div className=\"jumbotron text-center\">\n                <h1 className=\"display-3 \">Game Over</h1>\n                <h1 className=\"display-4 mb-5\">Better luck next time</h1>\n            </div>\n            <div className=\"d-flex justify-content-around m-5\" id=\"nav-btns\">\n                <LinkButton pathname=\"/play\" displayText=\"Play Again\"/>\n                <LinkButton pathname=\"/\" displayText=\"Back Home\"/>\n            </div>\n        </React.Fragment>\n    );\n}","import React from \"react\"; \nimport LinkButton from \"../LinkButton/LinkButton\";\n\nexport default function ErrorPage(props) {\n    return (\n        <React.Fragment>\n            <div className=\"jumbotron text-center\">\n                <h1 className=\"display-3 \">Sorry</h1>\n                <h1 className=\"display-4 mb-5\">That's not a valid page...</h1>\n            </div>\n            <div className=\"d-flex justify-content-around m-5\" id=\"nav-btns\">\n                <LinkButton pathname=\"/\" displayText=\"Home\"/>\n                <LinkButton pathname=\"/learn\" displayText=\"Learn More\"/>\n                <LinkButton pathname=\"/play\" displayText=\"Play Nim\"/>\n            </div>\n        </React.Fragment>\n    );\n}","import React from 'react';\nimport queryString from 'query-string'\nimport WinPage from '../WinPage/WinPage.js'\nimport LosePage from '../LosePage/LosePage.js'\nimport ErrorPage from '../ErrorPage/ErrorPage.js'\n\n\nexport default function GameOverPage(props) {\n    const values = queryString.parse(props.location.search)\n    let GameOverScreen;\n    if (values.winner === \"AI\") {\n        GameOverScreen = LosePage;\n    } else if (values.winner === \"User\"){ \n        GameOverScreen = WinPage;\n    } else {\n        GameOverScreen = ErrorPage;\n    }\n    return (\n        <GameOverScreen/>\n    );\n}","import React from 'react';\nimport LinkButton from '../LinkButton/LinkButton.js';\nimport './TitlePage.css';\n\nexport default function TitlePage() { \n    return (\n        <section id=\"title-page\">\n            <h1>NIM</h1>\n            <div id=\"title-buttons\">            \n                <LinkButton pathname=\"/learn\" displayText=\"Learn More\"/>\n                <LinkButton pathname=\"/play\" displayText=\"Start Playing\"/>\n            </div>\n        </section>\n    );\n}","import React from 'react';\nimport './TransitionRouteWrapper.css';\n\nexport default function TransitionRouteWrapper(WrappedComponent) {\n    function ExtendedComponent(props) { \n        return (\n            <div className=\"route\">\n                <WrappedComponent location={props.location}>\n                    {props.children}\n                </WrappedComponent>\n            </div>\n        );\n    }\n    return ExtendedComponent;\n}","import React from 'react'; \nimport './NimTopBar.css'\n\nexport default function NimTopBar(props) {\n    return (\n        <React.Fragment>\n            <nav className=\"navbar mb-2\">\n                <a className=\"navbar-brand\" href=\"/\">Nim</a>\n            </nav>\n            {/* <div className=>\n\n            </div> */}\n        </React.Fragment>\n    );\n}\n\n","import React, { Component } from 'react';\nimport MatchGame from './MatchGame/MatchGame.jsx'; \nimport GameOverPage from './GameOverPage/GameOverPage.js'; \nimport { BrowserRouter as Router, Route, Switch } from \"react-router-dom\";\nimport { TransitionGroup, CSSTransition } from \"react-transition-group\";\nimport TitlePage from './TitlePage/TitlePage.jsx';\nimport TransitionRouteWrapper from './TransitionRouteWrapper/TransitionRouteWrapper.jsx';\nimport ErrorPage from './ErrorPage/ErrorPage.js';\nimport NimTopBar from './NimTopBar/NimTopBar.js'\nimport './App.css';\n\nclass App extends Component {\n    routerRender = ({location}) => { \n        const WrappedTitlePage = TransitionRouteWrapper(TitlePage)\n        const WrappedGameOverPage = TransitionRouteWrapper(GameOverPage)\n        const WrappedLearnPage = TransitionRouteWrapper(MatchGame)\n        const WrappedPlayPage = TransitionRouteWrapper(MatchGame)\n        const WrappedErrorPage = TransitionRouteWrapper(ErrorPage)\n        return (\n            <TransitionGroup>\n                <CSSTransition\n                    key={location.key}\n                    timeout={1000}\n                >\n                    <Switch location={location}>\n                        <Route exact path=\"/\" component={WrappedTitlePage}/>\n                        <Route path=\"/learn\" component={WrappedLearnPage}/>\n                        <Route path=\"/play\" component={WrappedPlayPage}/>\n                        <Route path=\"/gameover\" component={WrappedGameOverPage}/>\n                        <Route component={WrappedErrorPage}/>\n                    </Switch>\n                </CSSTransition>\n            </TransitionGroup>\n        );\n    }\n    render() {\n        return (\n            <Router basename={process.env.PUBLIC_URL}>\n                <NimTopBar/>\n                <Route render={this.routerRender}/>\n            </Router>\n        );\n    }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}